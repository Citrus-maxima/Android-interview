## Q1：Activity卡顿原因及优化

| 原因             | 描述                                                         | 解决方案                                                     |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 内存泄漏         | 内存泄漏导致内存占用较高，导致JVM频繁触发GC                  |                                                              |
| 加载大数据       | 主要是图片资源Bitmap，占用太多内存，导致JVM频繁GC            | - 压缩图片：根据需显示的Bitmap宽高，设定采样率<br />- 缓存图片：采用LRUCache方法<br />- 若是其他大数据（如3D模型数据），则可以使用Native空间 |
| UI线程做耗时任务 | 如数据库操作、数据计算等。不卡顿频率：1秒绘制60帧，即16.6ms要刷新一次 | 另起工作线程执行耗时任务，网络加载数据进行异步请求 |
| UI视图过度绘制   | 绘制时间过长                                                 | 减短UI视图的绘制时间                                         |
| 布局复杂         | 加载布局时间久                                               | - 优化布局，不要嵌套太深<br />- 使用\<include>标签<br />- 图片不要做得过大，要适中<br />- 不可见视图需要时加载 |
| 应用内多进程     | 从FirstActivity跳转到SecondActivity，如果这两个界面不属于同一个进程，首次跳转的时候会创建一个新的进程，创建进程是比较耗时的，比跳转到同一进程内的新页面耗时更多 | 如果不是必须要在应用内使用多进程，不要在应用内使用多进程     |

