## Q1：100*100的图片在内存中占用的大小

一般的，计算一张图片占用的内存大小公式：分辨率 * 每个像素点的大小。每个像素点的大小：在Android中一般我们会以RGB_565或者ARGB_8888格式加载位图，其中RGB_565表示：R占用5位数据，G使用6位表示，B也是5位，则一个像素点为：16位两字节。比如100x100分辨的图片，以RGB_565加载进入内存，则其内存大小为：100x100x2 = 20000 字节。

但是需要注意的是：使用 Android BitmapFactory 加载 Bitmap时，如果加载res目录下的图片，图片被加载进内存时的分辨率会经过一层转换，所以，虽然最终图片大小的计算公式仍旧是分辨率*像素点大小，但此时的分辨率已不是图片本身的分辨率了，系统会根据设备当前的 dpi 值以及资源目录所对应的 dpi 值，做一次分辨率转换，规则如下：

> 转换后高度 = 原图高度 * (设备的 dpi / 目录对应的 dpi )
>
> 转换后宽度 = 原图宽度 * (设备的 dpi / 目录对应的 dpi )

如：设备240dpi，100x100的图片放在drawable-hdpi，使用BitmapFactory.decodeResource加载的内存为：转换后分辨率：100 * (240 / 240）* 100 * (240 / 240) ，则此图片内存占用为：100 * 100 * 像素大小。

而如果将图片放入 mdpi 中，则内存占用为：100 * (240 / 160) * 100 * (240 / 160)  * 像素大小 ，图片内存会比hdpi更大。

如果图片不是通过BitmapFactory.decodeResource加载，则不会出现上述被转换的情况。

## Q2：进程优先级

在Android系统中，进程管理是通过一个称为“adj优先级”（Adjustment优先级）的机制来进行的。这个机制决定了系统在资源不足时如何优先处理进程的终止。`adj`优先级值越小，进程的优先级越高，系统更不可能终止该进程。反之，`adj`值越大，优先级越低，进程更容易被终止。

以下是一些常见的adj优先级分类，从高到低（值从小到大）：

1. **Foreground App (前台应用) - `adj`值：0**
   - 当前正在用户前台交互的应用。这些应用的优先级最高，通常不会被终止。

2. **Visible App (可见应用) - `adj`值：1**
   - 例如，虽然不在前台显示，但其内容可能仍然部分可见（如分屏或对话框）。

3. **Perceptible App (感知到的应用) - `adj`值：2**
   - 用户可以感知到其存在，但它不完全在前台，比如正在播放音乐的后台应用。

4. **Service (服务) - `adj`值：3**
   - 持有服务（Service）的应用。这些服务对用户体验是重要的，如后台播放音乐或维持联网状态。

5. **Cached App (缓存应用) - `adj`值：9到15**
   - 这些应用最近使用过但当前不活跃，且不持有任何活动的服务、广播接收器等。系统在内存不足时会优先终止这些进程以释放资源。

6. **Empty App (空进程) - `adj`值：16到MAX**
   - 没有任何应用组件正在运行的进程。这些进程仅为了快速启动应用而保留。系统最容易终止这些进程。

具体的adj值可能因设备和系统版本的不同而有所差异。系统会根据内存和其他资源的使用情况，动态调整进程的adj优先级，以确保最佳性能和用户体验。

## Q3：系统怎么阻止应用保活

### 1. **后台限制（Background Restrictions）**

从Android 8.0（Oreo）开始，系统对后台应用的行为进行了更严格的限制，特别是在后台服务和广播接收器的使用上：

- **后台服务限制**: 限制后台运行的服务。应用程序在进入后台后，不能无限期地运行服务。如果应用需要在后台执行任务，可以使用前台服务（Foreground Service）或JobScheduler来调度任务。

- **隐式广播限制**: 阻止不必要的隐式广播。系统会限制应用注册的隐式广播接收器，这样即使收到广播，也不会唤醒应用。

### 2. **电池优化（Battery Optimization）**

Android系统提供了一种电池优化机制，即Doze模式和应用待机（App Standby）模式：

- **Doze模式**: 当设备长时间闲置时（例如屏幕关闭且设备静止），系统会进入Doze模式，限制应用的网络访问、后台任务执行和同步，直到设备退出此模式。

- **应用待机模式**: 系统会检测应用的使用情况，如果某个应用长时间未被使用，它将被置于待机模式，限制网络访问和任务调度。这对那些试图通过后台保活的应用有很大的限制作用。

### 3. **前台服务通知要求**

从Android 9.0（Pie）开始，所有的前台服务都必须提供一个通知（Notification），以便用户能够明确知道哪些应用在使用系统资源。如果用户认为某个应用不应该保活，可以手动关闭应用或前台服务。

### 4. **限制唤醒锁（Wake Lock）**

唤醒锁是Android中一种机制，允许应用保持设备的CPU不进入休眠状态。从Android 6.0（Marshmallow）开始，系统对唤醒锁的使用进行了严格的控制，应用不能长期持有唤醒锁，以防止设备无法进入低功耗模式。

### 5. **内存管理**

Android系统会根据设备的内存状态，自动管理应用的生命周期。内存紧张时，系统会优先终止空闲或长时间不活动的后台进程。这种机制确保系统资源用于当前用户最需要的应用和服务。

### 6. **应用权限控制**

用户可以通过系统设置，手动限制应用的后台行为。例如，在电池设置中，用户可以为特定应用禁用后台运行权限。这种方式对于那些试图在后台保活的应用非常有效。

### 7. **清理应用**

一些设备制造商提供了自定义的电池管理或系统优化工具，这些工具会定期清理不必要的后台进程，关闭消耗资源的应用。

这些机制和策略结合起来，有效地防止应用在后台过度消耗资源，延长设备的电池寿命，并确保系统的平稳运行。开发者需要遵循这些规则，以确保应用在不影响用户体验的前提下正常运行。
