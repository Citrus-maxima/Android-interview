## Q1：为什么要专门使用Zygote进程去孵化应用进程，而不是让System Server去孵化呢？

## Q2：具体说说怎样导致死锁的？

## Q3：Android系统启动流程

## Q4：SystemServer为什么要在Zygote中启动，而不是由init直接启动？

## Q5：Zygote为什么不采用Binder机制进行IPC通信？

## Q6：Zygote启动过程

1. 解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；
   
2. 调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；

3. 通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；

4. registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；

5. preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率；

6. zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。

7. zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。

## Q7：uid是如何分配的，分配uid要遵循什么原则？

## Q8：Java类加载器和Android类加载器

- Java类加载器

![image](https://github.com/user-attachments/assets/4b5432cc-d968-42e2-85e9-3a6a09455d0c)

BootstrapClassLoader，启动类加载器，主要加载的是JVM自身需要的类，这个类加载使用 C++语言实现是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中。

ExtensionClassLoader，扩展类加载器，负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类，开发者可以直接使用标准扩展类加载器。

ApplicaitonClassLoader，也叫SystemClassLoader，应用程序类加载器，它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader() 方法可以获取到该类加载器

- Android类加载器

![image](https://github.com/user-attachments/assets/5a03ab86-1eba-4284-b59d-b71ba6bd2dad)

BootClassLoader用于加载一些Android系统框架的类，其中就包括APP用到的一些系统类，用Java实现。

BaseDexClassLoader派生出两个子类加载器：PathClassLoader:主要用于系统和app的类加载器；DexClassLoader: 可以从包含classes.dex的jar或者apk中，加载类的类加载器, 可用于执行动态加载, 但必须是app私有可写目录来缓存odex文件. 能够加载系统没有安装的apk或者jar文件，因此很多热修复和插件化方案都是采用DexClassLoader。
