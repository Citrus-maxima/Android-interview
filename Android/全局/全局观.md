## Q1：为什么要专门使用Zygote进程去孵化应用进程，而不是让System Server去孵化呢？

## Q2：具体说说怎样导致死锁的？

## Q3：Android系统启动流程

## Q4：SystemServer为什么要在Zygote中启动，而不是由init直接启动？

## Q5：Zygote为什么不采用Binder机制进行IPC通信？

## Q6：Zygote启动过程

1. 解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；
   
2. 调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；

3. 通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；

4. registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；

5. preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率；

6. zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。

7. zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。

## Q7：uid是如何分配的，分配uid要遵循什么原则？

## Q8：
